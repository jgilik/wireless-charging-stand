// Copyright 2014 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file contains enum definitions, allowing us to reason about the config.
include <enums.scad>;

// This file sets some variables to some enum settings.  It's generated by
// ./configure.sh.
include <config.scad>;

///////////
// PHONE //
///////////

phone_heights = [0, 140, 140, 138];
phone_widths = [0, 72, 72, 69];
phone_depths = [0, 12, 14, 10];
phone_sweet_spots = [0, 70, 70, 68.5];
phone_height = phone_heights[phone_type];
phone_width = phone_widths[phone_type];
phone_depth = phone_depths[phone_type];
phone_sweet_spot = phone_sweet_spots[phone_type];
echo(
  phone_type=phone_type,
  phone_height=phone_height,
  phone_width=phone_width,
  phone_depth=phone_depth,
  phone_sweet_spot=phone_sweet_spot
);


charger_is_pucks = [1, 1, 1, 0];
// +1s here are fudge factor
charger_diameters = [0, 70 + 1, 60 + 1, 60 + 1];
charger_heights = [0, 10.5, 12.0, 12.5]; 
puck_charger = charger_is_pucks[charger_type];
puck_diameter = charger_diameters[charger_type];
puck_height = charger_heights[charger_type];
echo(
  charger_type=charger_type,
  puck_charger=puck_charger,
  puck_diameter=puck_diameter,
  puck_height=puck_height
);

// internals
intersection_fudge = 0.1;

//////////
// PUCK //
//////////

module puck() {
  if (puck_charger == 1) {
    linear_extrude(height=puck_height)
    circle(d=puck_diameter, $fn=300);
  } else {
    linear_extrude(height=puck_height)
    square([puck_diameter, puck_diameter], center=true);
  }
}

// Where's the puck's sweet spot?
// This is measured with the puck in the sweet spot, from the top
// of the puck to the bottom of the phone, with the case on.
puck_sweet_spot = phone_sweet_spot + puck_diameter / 2;


///////////////
// BACKPLATE //
///////////////

// The backplate is the thing the charger sits on.

// How much extra width to put at the thinnest part of the plate,
// at the top on the sides of the puck.
plate_h_padding = (phone_width - puck_diameter) / 2;
// How much additional space to put below the puck.
plate_v_padding = puck_sweet_spot - puck_diameter;
// Thickness of the part of the backplate behind the puck.
plate_depth = 5;

plate_height =
  puck_diameter/2 + plate_v_padding + intersection_fudge;
plate_width = puck_diameter + plate_h_padding * 2;

module plate() {
//  translate([0, -plate_height/2, -plate_depth - intersection_fudge])
  translate([0, -plate_height/2, 0])
  linear_extrude(height=puck_height + plate_depth)
  square([plate_width, plate_height], center=true);

  linear_extrude(height=plate_depth + intersection_fudge)
  circle(d=plate_width, $fn=300);
}

// We want a hole for the USB cable, though!
// How far do we want to move it up from just barely touching the
// puck's circle?
usb_v_offset = 3;
// How wide do we want the hole to be?
usb_width = 12.5;
// How long do we want the hole to be?
// Set to very high values for "all the way"...
//usb_length = 35;
usb_length = 100;
// Should the hole extend through the ledge plate?
usb_through_ledge = 1;
// Should the hole extend through the base?
usb_through_base = 1;

// Do we want to have a back wall for the cable passageway?
usb_back_plate = 1;
// If so, how long should that cover be?
usb_back_plate_length = 25;
// How thick should it be?
usb_back_plate_depth = 2;

// Cover up the hole a tiny bit: how thick should the cover be?
usb_facade_thickness = 2;
module usb_hole() {
  translate([
    0,
    -puck_diameter/2 - usb_length/2 + usb_v_offset,
    -intersection_fudge
  ])
  linear_extrude(height=plate_depth + puck_height + intersection_fudge - usb_facade_thickness)
  square([usb_width, usb_length], center=true);
}
module usb_back_plate() {
    translate([
      0,
      -puck_diameter/2 - usb_back_plate_length/2 + usb_v_offset,
      0
    ])
    linear_extrude(height=usb_back_plate_depth)
    square([usb_width + intersection_fudge * 2, usb_back_plate_length + intersection_fudge], center=true);    
}

module plate_with_usb_hole() {
  if (usb_back_plate == 1) {
    usb_back_plate();
  }
  difference() {
    plate();
    usb_hole();
  }
}



///////////
// LEDGE //
///////////

// The ledge is the thing the phone sits on.

// The lip is a little retainer to make sure your phone doesn't tilt
// back and fall over.
lip_thickness = 2;
// Depth of the ledge is how far in front of the backplate we want
// the ledge to protrude.
// Derived from quick caliper measurement of N5, case, and charger
ledge_depth = phone_depth + lip_thickness;
// The total depth includes the components the ledge will intersect
// with to avoid silly polygon intersection issues.
ledge_depth_total = ledge_depth + plate_depth + puck_height;
// Width of the ledge should likely match the backplate width.
ledge_width = plate_width;
// How much additional space below the phone should appear?
ledge_length = 2;

// How much do we want the ledge to "pop up" to support the phone?
phone_recess_depth = 3.5;
ledge_length_total = ledge_length + phone_recess_depth;

module ledge_block() {
  // This generates the block
  translate([0, -plate_height - ledge_length/2, 0])
  linear_extrude(height=ledge_depth_total)
  square([ledge_width, ledge_length_total], center=true);
}
module ledge_recess() {
  // This is our phone's little recess
  translate([0, -plate_height + phone_recess_depth/2, plate_depth + puck_height])
  resize(newsize=[ledge_width, phone_recess_depth*2, ledge_depth + intersection_fudge])
  linear_extrude(height=ledge_depth)
  circle(d=ledge_width, $fn=100);
}
module ledge_lip() {
  // Rectangular portion
  translate([0, -plate_height - ledge_length/2, ledge_depth + puck_height + plate_depth - lip_thickness])
  linear_extrude(height=lip_thickness)
  square([ledge_width, ledge_length_total], center=true);

  // Curved portion
  translate([0, -plate_height + phone_recess_depth/2, ledge_depth + puck_height + plate_depth - lip_thickness])
  resize(newsize=[ledge_width, phone_recess_depth*2, lip_thickness])
  linear_extrude(height=lip_thickness)
  circle(d=ledge_width, $fn=100);
}
module ledge() {
  difference() {
    color("blue")
    ledge_block();
    color("red")
    ledge_recess();
  }
  color("blue")
  ledge_lip();
}
module ledge_with_usb_hole() {
  difference() {
    ledge();
    if (usb_through_ledge == 1) {
      usb_hole();
    }
  }
}


//////////
// BASE //
//////////

// The base actually provides gravity resistance.
stand_angle = 25;
base_height = 5;
base_width = plate_width;
base_depth = 40;

// Whether or not to have walls up the side of the base plate.
enable_walls = 1;
// What angle from vertical to have the walls come towards the rest
// of the phone stand.
wall_angle = 10;
// How thick the walls should be
wall_depth = 5;
module stand() {
  translate([0, plate_height + ledge_length + phone_recess_depth/2, 0])
  difference() {
    union() {
      plate_with_usb_hole();
      ledge_with_usb_hole();
    }
    translate([0,0, plate_depth + intersection_fudge])
    puck();
  };
}

// This is the block beneath the plate.
module plate_base() {
  difference() {
    // This is the actual plate.
    translate([0, base_depth/2, 0])
    linear_extrude(height=base_height)
    square([base_width, base_depth], center=true);

    // And the hole to put the USB cable through...
    if (usb_through_base == 1) {
      translate([0, base_depth/2, -intersection_fudge])
      linear_extrude(height=base_height + intersection_fudge*2)
      square([usb_width, base_depth + intersection_fudge], center=true);
    }
  }
}
// This is the block beneath the ledge.
ledge_base_depth = ledge_depth_total * cos(stand_angle);
ledge_base_height = ledge_depth_total * sin(stand_angle);
module ledge_base() {
  translate([-base_width/2, -ledge_base_depth, 0])
  rotate([90,0,0])
  rotate([0,90,0])
  linear_extrude(height=base_width)
  polygon(
    points=[
      [0, 0],
      [ledge_base_depth, 0],
      [ledge_base_depth, intersection_fudge],
      [intersection_fudge, ledge_base_height],
      [0, ledge_base_height]
    ],
    paths=[
      [0, 1, 2, 3, 4]
    ]
  );
}
module plate_walls() {
  stand_slope = -tan(90 - stand_angle);
  echo(stand_slope=stand_slope);
  wall_slope = tan(90 - wall_angle);
  echo(wall_slope=wall_slope);
  stand_intercept = -base_depth * stand_slope;
  echo(stand_intercept=stand_intercept);
  intersection_x = stand_intercept / (wall_slope - stand_slope);
  intersection_y = intersection_x * wall_slope;
  echo(intersection=[intersection_x, intersection_y]);

  for (i = [-1, 1]) {
  translate([i*(base_width-wall_depth)/2, base_depth, 0])
  rotate([90,0,0])
  rotate([0,-90,0])
  linear_extrude(height=wall_depth, center=true)
  polygon(
    points=[
      [0, 0],
      [0, base_height],
      [intersection_x, intersection_y],
      [intersection_x + intersection_fudge, intersection_y],
      [base_depth + intersection_fudge, 0]
    ],
    paths=[
      [0, 1, 2, 3, 4]
    ]
  );
  };
}


module full_stand() {
  color("grey")
  plate_base();
  color("yellow")
  ledge_base();


  rotate([90 - stand_angle,0,0])
  stand();
}

plate_walls();
full_stand();
